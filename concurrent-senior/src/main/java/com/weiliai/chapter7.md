#Java并发包中并发队列原理剖析
JDK中提供了一系列场景的并发安全队列,总得来说按照实现方式的不同分为阻塞队列和非阻塞队列.
阻塞队列:使用锁实现
非阻塞队列:使用CAS非阻塞算法实现

##ConcurrentLinkedQueue原理探究
ConcurrentLinkedQueue是线程安全的无界非阻塞队列,其底层数据结构使用单向链表实现,对于入队和出队操作使用CAS来实现线程安全.
ConcurrentLinkedQueue内部的对列使用的是单向链表实现,并且有两个用volatile修改的节点头结点head和tail尾节点.

offer操作是在队列的尾部添加一个元素,如果提供的元素为null,则会抛出一个异常
poll获取在队列头部的节点,并移除,如果队列为空,则返回null

参考资料:
http://ifeve.com/concurrentlinkedqueue/

##LinkedBlockingQueue原理探究
LinkedBlockingQueue也是使用的单向链表实现的,也有两个Node,分别用来代表首节点和尾节点,一个AtomicInteger类型的count表示队列的元素个
数,另外还有两个ReentrantLock类型的实例,分别控制入队和出队的原子性,其中takeLock用来控制同时只有一个线程可以获取锁,在队列尾部获取元
素,其他线程必须等待,putLock用来控制同时只能有一个线程获取锁,在队列尾部添加元素,其他线程必须等待,以及两个Condition类型条件变量

poll出队(非阻塞),peek出队(非阻塞),take出队(阻塞)
poll:出队会删除出队元素
peek:出队不会删除
take:出队删除,并且是阻塞的

LinkedBlockingQueue使用两把条件锁实现入队和出队

##ArrayBlockingQueue原理探究
ArrayBlockingQueue中有一个Object类型的数组,用来存放队列元素,putIndex,takeIndex分别代表入队和出队索引,count代表队列元素个数,从定
义可知,这些变量都没有使用volatile修改,因为相关的操作都是在锁内的,而锁又可以满足可见性和原子性,另外有两个条件变量notEmpty和notFull
来控制入队和出队的同步.

ArrayBlockingQueue使用全局独占锁实现了同时只有一个线程进行入队和出队操作,这个锁的粒度比较大和在方法上添加synchronized关键字类似

##PriorityBlockingQueue原理探究
PriorityBlockingQueue是带优先级的无界阻塞队列,每次出队都是优先级最高或者最低的元素,其内部是使用平衡二叉树堆实现的,所以直接遍历队列
元素不保证有序,默认使用的是compareTo方法提供的比较规则,如果需要自定义比较规则则可以自定义comparators.

PriorityBlockingQueue内部是一个数组queue,用来存放队列元素,size用来存放队列元素个数,allocationSpinLock是个自旋锁,其使用CAS操作来
保证同时只有一个线程可以扩容队列,状态为0或者1,其中0表示没有扩容,1表示正在扩容.
由于它是一个优先级队列,所以有一个比较器comparator用来比较元素大小,lock独占锁对象用来控制同时只能是一个线程可以进行入队,出队操作.
notEmpty条件变量,用来实现take方法阻塞模式,没有notFull条件变量是因为put操作是非阻塞的,为啥设计为非阻塞,应为它是无界队列.

涉及的代码:com.weiliai.chapter7.TestPriorityBlockingQueue

##DelayQueue原理探究
DelayQueue并发队列是一个无界阻塞延迟队列,队列中每个元素都有个过期时间,当从队列获取元素时,只有过期的元素才会出队列,队列头是最快要过
期的元素.
DelayQueue延迟队列内部使用PriorityQueue存放数据,使用ReentrantLock实现线程同步.另外,队列里边的元素都要实现Delayed接口,由于每个元
素都有一个过期时间,所以要实现获知当前元素还有多久时间过期的接口,由于内部是有优先级队列来实现,所以要实现元素之间相互比较的接口Delayed
接口.


参考资料:
https://www.cnblogs.com/nxzblogs/p/11337361.html