#Java并发包中线程同步器原理剖析
##CountDownLatch原理剖析
在开发过程中经常会遇到在主线程中开启多个子线程去并行执行任务,并且主线程需要等待子线程执行完毕后在进行汇总.在CountDownLatch出现之前
使用线程的join方法,但是join方法不灵活.

###join方法和CountDownLatch区别
当调用线程的join方法后,主线程会一直等待子线程执行完毕后,主线程才能继续执行;而CountDownLatch的await方法,则是当子线程调用了
countDown方法后(如果计数器降为0),无论子线程中是否执行完,主线程都会继续向下执行,并不一定等待子线程执行完所有的代码.

##回环屏障CyclicBarrier原理探究
CountDownLatch在一定程度上优化了join方法,但是CountDownLatch的计数器一点变为0,当下次调用await时就不不起作用,即不能重复使用.而
CyclicBarrier则优化了这一点,使屏障点可以重复使用,它可以让一组线程全部达到一个状态后再全部同时执行.
之所以叫做回环是因为当所有线程执行完毕,并重置CyclicBarrier的状态后它可以被重用.
之所以叫做屏障是因为线程调用await方法后就会被阻塞,这个阻塞点就称为屏障点,等所有线程都调用了await方法,线程们就会冲破屏障,继续运行.

##信号量Semaphore原理探究
Semaphore信号量也是java中的同步器,和CountDownLatch和CyclicBarrier不同的是,它内部设计的计数器是递增的,并且在一开始初始化Semaphore
时可以指定一个初始值,但是它并不需要知道需要同步的线程的个数,而是在需要同步的时候调用acquire方法时指定需要同步的线程个数.

Semaphore也是使用AQS实现的,并且获取信号量时有公平策略和非公平策略之分.



##参考资料
https://www.cnblogs.com/nxzblogs/p/11349420.html