#并发编程的其他基础知识
##并行与并发的概念
并发是指在同一时间段内多个任务同时都在执行,并且都没有执行结束(同一时间段又包括多个单位时间,也就是说一个cpu执行多个任务)
并行是指单位时间内多个任务同时执行(也就是多个cpu同时执行任务).
并发任务强调的在一个时间段内同时执行,而一个时间段有多个单位时间累计而成,所以说并发多个任务在单位时间内不一定同时执行.
多线程编程实践中,线程的个数一般是多于cpu的个数的

##为什么要多线程并发编程
多个cpu同时执行多个任务,减少了线程上下文切换的开销

##Java中的线程安全问题
共享资源是指资源被多个线程所持有或者说多个线程都可以访问该资源.
线程安全问题是指多个线程同时读写一个共享资源并且没有任何同步措施时,导致出现脏数据或其他不可预见的结果问题.

##Java中共享变量的内存可见性问题
java内存模型(JMM)规定,所有的变量都存储在主内存中,当线程使用变量时,会将主内存中的变量复制一份到自己的工作内存,之后线程操作的变量都是
自己工作内存(L1缓存或者L2缓存或者寄存器)中的变量.

当一个线程操作共享变量时,它首先从主内存共享变量到自己的工作内存,然后对工作内存里的变量进行处理,处理完成后将变量值更新到主内存(读-改-写).
内存不可见问题,通过关键字synchronized或volatile,具体描述详看书籍.

##Java中synchronized关键字
synchronized块是Java提供的一种原子性内置锁,Java中每个对象都把她当作一个同步锁来使用,这些Java内置的使用者看不到的锁称为内置锁,也叫
监视器锁.内置锁是排他锁.

synchronized内存语义就是解决共享变量内存可见性问题.
进入synchronized代码块时,把块内使用到的变量从线程的工作内存中清除,直接使用主内存中的变量数据,
退出synchronize块时,将对共享变量的操作刷新到主内存.

加锁和解锁的语义:
加锁是清空线程工作缓存中共享变量的值,在使用的时候直接加载主内存中的数据,释放锁的时候,将线程内共享变量的数据刷回到主内存中

##Java中的volatile关键字
volatile可以保证在对共享变量操作时对其他线程是可见的,volatile能够保证可见性,但是不能保证原子性(synchronized能够保证可见性和原子性)
写入volatile变量等价于退出synchronized同步块(把写入工作内存的变量值同步到主内存)
读取volatile变量等价于进入synchronized同步块(先清空本地内存变量值,再从主内存中获取最新值)

##Java中的原子操作
原子操作指的是一系列操作要么都执行成功,要么都失败.
例如:程序计数器 ++count; 操作就不是一个原子操作,因为它内部设计到读-改-写三个操作.

##Java中CAS操作
CAS即compare and swap操作是jdk提供的非阻塞的原子操作,它通过硬件来保证“比较-更新”操作的原子性.
CAS中的一个经典问题ABA问题,该问题产生的原因就是变量产生了环形转换,也就是变量A->B->A.
AtomicStampedReference能够解决ABA问题(通过给每一个变量加了一个时间戳)

涉及代码:com.weiliai.chapter2.VolatileTest

##UnSafe类
UnSafe类提供了硬件级别的原子操作方法(不建议在代码中使用该类)
unsafe.objectFieldOffset(Field field):返回偏移量,理解为内存里java对象的各个部分放在内存的不同位置,而该方法则会返回指定字段相对于
java对象的“起始地址”的偏移量,后续可以通过unsafe的getInt,getLong等方法,通过偏移量直接获取java对象的某个字段

涉及的代码:
com.weiliai.chapter2.UnSafeTest
com.weiliai.chapter2.TestUnSafe

##指令重排序
java内存模型允许编译器和处理器对指令进行重排序以提供性能,并且只会对不存在数据依赖性的指令重排序.
在单线程下指令重排序对最终结果没有影响,但是在多线程下就会存在问题.

涉及代码:com.weiliai.chapter2.InstructionReorder

##什么是伪共享
当多线程修改互相独立的变量时,如果这些变量共享同一个缓存行,就会无意中影响彼此的性能,这就是伪共享.

避免伪共享的主要思路就是让不相干的变量不要出现在同一个缓存行中.

避免伪共享的主要思路就是让不相干的变量不要出现在同一个缓存行中;
1.每两个变量之间加七个long类型;
2.创建自己的 long 类型,而不是用原生的;
3.使用 java8 提供的注解;
涉及的代码:com.weiliai.chapter2.FalseSharingTest

##锁
乐观锁和悲观锁:事务性
公平锁和非公平锁:获取所的机制(先到先得就是公平,随机抢占就是非公平的)
独占和共享锁:能够被多个线程共同持有
可重入锁:持有锁的对象是自己时,不会被阻塞
自旋锁:当线程在获取锁的时候,发现锁已被其他线程占用,此时该线程并不会立刻阻塞,而是循环多次获取(默认次数为10次),扔获取不到时,才会阻塞线程.
其中阻塞此时可以设置-XX:PreBlockSpinsh

##参考资料
https://www.cnblogs.com/nxzblogs/p/11329270.html